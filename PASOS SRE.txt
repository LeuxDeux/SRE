1) Crear base de datos básica de usuarios:
CREATE TABLE `usuarios` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(100) NOT NULL,
  `password_hash` varchar(255) NOT NULL,
  `email` varchar(255) DEFAULT NULL,
  `role` enum('secretaria','admin') DEFAULT 'secretaria',
  `secretaria` varchar(100) DEFAULT NULL,
  `activo` tinyint(1) DEFAULT '1',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
)
2) Crear workspace
Dividir zona de trabajo frontend-backend
Frontend: npx create-react-app .
Backend: npm init -y -> npm install express cors bcryptjs jsonwebtoken mysql2 dotenv socket.io

3) Añadir repositorio remoto y hacer un add->commit->push
4) Crear estructura de carpetas ordenada
5) Crear config/database.js o sea, conexión con la base de datos, para este caso paquetes mysql2 y dotenv, forma de crear conexión siempre POOL. Exportar el modulo y probarlo de la manera que sea.
6) Creación de server.js simple con ruta / con un solo mensaje y timestamp y un /api/health
7) Creación de authController.js con su route auth.js logica de autentificacion para pruebas sin front: 
   -curl -X POST http://localhost:5000/api/auth/login -H "Content-Type: application/json" -d "{\"username\":\"admin\",\"password\":\"password\"}"
   -curl -X GET http://localhost:5000/api/auth/verify -H "Authorization: Bearer TU_TOKEN_AQUI"
8) Creación de services/api.js con interceptores para debug y para agregar el token JWT y su primer servicio api authAPI para el login y verify
9) Creación de context/AuthContext.js como componente global con hook que maneja datos del usuario, estado de carga y mensajes de error y por último verifica con el backend si el token sigue válido.
10) Creación de App.js para pruebas con datos hardcodeados que verifiquen la correcta implementación de la api y el contexto para sesion.
-TENER EN CUENTA: 
# Redirigir /api/ al backend Node.js
ProxyPass /api/ http://localhost:5000/
ProxyPassReverse /api/ http://localhost:5000/

# Servir archivos estáticos de React
DocumentRoot /var/www/html
11) Creación de LoginForm.jsx con su useState para manejar credenciales, useAuth como hook para acceder al contexto de autentificacion (AuthContext) y LoginForm.css con sus estilos. handleSubmit() llama a la función login() de AuthContext y renderiza el componente
12) Modificación de App.js temporal, muestra la pantalla principal si el usuario está logueado y renderiza los modulos en función de si es usuario normal o administrador.
13) Creación de nueva tabla "eventos:
CREATE TABLE eventos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(255) NOT NULL,
    fecha_evento DATE NOT NULL,
    descripcion TEXT,
    archivo_adjunto VARCHAR(500), -- ruta del archivo
    categoria ENUM('Académico', 'Cultural', 'Administrativo', 'Urgente') DEFAULT 'Académico',
    
    -- Datos internos
    usuario_id INT NOT NULL,
    secretaria VARCHAR(100) NOT NULL,
    fecha_carga TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ultima_modificacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id),
    INDEX idx_fecha_evento (fecha_evento),
    INDEX idx_categoria (categoria)
);
Que luego se cambia "categoria" por una tabla propia:
CREATE TABLE `eventos` (
  `id` int NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  `fecha_evento` date NOT NULL,
  `descripcion` text,
  `archivo_adjunto` varchar(500) DEFAULT NULL,
  `categoria_id` int DEFAULT NULL,
  `usuario_id` int NOT NULL,
  `secretaria` varchar(100) NOT NULL,
  `fecha_carga` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `ultima_modificacion` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `usuario_id` (`usuario_id`),
  KEY `idx_fecha_evento` (`fecha_evento`),
  KEY `categoria_id` (`categoria_id`),
  CONSTRAINT `eventos_ibfk_1` FOREIGN KEY (`usuario_id`) REFERENCES `usuarios` (`id`),
  CONSTRAINT `eventos_ibfk_2` FOREIGN KEY (`categoria_id`) REFERENCES `categorias` (`id`)
)
14) Creacion de controller eventosController.js para manejar metodos CRUD
15) Creacion de route eventos.js
16) Creacion de nueva arquitectura middleware/auth.js para usarlo en routes.
17) Creacion de componente EventosTable.jsx y css EventosTable.css
18) Modificaciones en App.js para visualizaciones más precisas + App.css
19) Modificacion tabla usuarios:
ALTER TABLE usuarios 
ADD COLUMN nombre_completo VARCHAR(200) AFTER username; 
Para mostrar sus nombres y no username.
20) Creacion de componente EventoForm.jsx para registrar eventos en el sistema
21) Modificar App.js y EventoTable.jsx con sus props y rutas apropiadas
22) Instalación de Multer y creación de nuevo middleware/upload.js para manejar carga archivos con nuevo valor en bd archivo_adjunto VARCHAR
23) Modificacion de eventosController.js para tomar archivo adjunto como parametro.
24) Nuevas rutas de eventos.js con middleware para manejar archivos
25) Cambio en services/api.js para interceptor de FormData 
26) Creación de componente EventoDetail.jsx para mostrar detalles de cada evento y si hubo cambios en el mismo. Y creación de tabla historial_eventos:
CREATE TABLE `historial_eventos` (
  `id` int NOT NULL AUTO_INCREMENT,
  `evento_id` int NOT NULL,
  `usuario_id` int NOT NULL,
  `accion` enum('creado','actualizado','eliminado') DEFAULT NULL,
  `cambios` json DEFAULT NULL,
  `fecha` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `usuario_id` (`usuario_id`),
  KEY `idx_evento_id` (`evento_id`),
  KEY `idx_fecha` (`fecha`),
  CONSTRAINT `historial_eventos_ibfk_1` FOREIGN KEY (`evento_id`) REFERENCES `eventos` (`id`) ON DELETE CASCADE,
  CONSTRAINT `historial_eventos_ibfk_2` FOREIGN KEY (`usuario_id`) REFERENCES `usuarios` (`id`)
)
27) Refactorización de eventosController.js con mejor logica y manejo de funciones.
28) Próximo -> Categorias enum a nueva tabla para cargar categorias siendo admin
29) Creación tabla categorias:
CREATE TABLE categorias (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    color VARCHAR(7) DEFAULT '#3498db',
    activa BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
30) Creación de categoriasController.js para manejar nuevas categorías y obtenerlas
31) Creación de routes categorias.js
32) Creación de componente GestionCategorias.jsx
33) Siempre seguir orden:
a_ Tabla en base de datos.
b_ Controller.
c_ Rutas.
d_ Agregar rutas a server.js con app/server.use.
e_ Agregar rutas de uso al servicio api
f_ Crear componente que use esa API.
g_ Importar componentes hacia App.js
34) Cambios en codigo relevante a categorias para pasar a categorias_id
35) Instalación de paquetes jspdf y html12canvas para generación de pdfs en base a EventoDetail.jsx
36) Creación de frontend/src/utils/pdfGenerator.js
37) Modificación de tabla eventos para añadir nuevos valores: Correo de contacto, Telefono, Hora de inicio y finalización, espacio, publico destinatario, links relevantes, observaciones adicionales.
38) 
ALTER TABLE eventos 
ADD COLUMN correo_contacto VARCHAR(255),
ADD COLUMN telefono VARCHAR(50),
ADD COLUMN hora_inicio TIME,
ADD COLUMN hora_fin TIME, 
ADD COLUMN lugar VARCHAR(255),
ADD COLUMN publico_destinatario VARCHAR(100),
ADD COLUMN links TEXT,
ADD COLUMN observaciones TEXT;
39) Pruebas backend antes de hacer componentes:
curl -X POST http://localhost:5000/api/eventos \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer TU_TOKEN_JWT_AQUI" \
  -d '{
    "nombre": "Evento de Prueba con Nuevos Campos",
    "fecha_evento": "2024-12-15",
    "descripcion": "Descripción de prueba",
    "categoria_id": 1,
    "correo_contacto": "test@universidad.edu",
    "telefono": "+54 123456789",
    "hora_inicio": "09:00:00",
    "hora_fin": "13:00:00",
    "lugar": "Aula Magna",
    "publico_destinatario": "Estudiantes y Docentes",
    "links": "https://forms.google.com/inscripcion, https://meet.google.com/evento",
    "observaciones": "Observaciones adicionales de prueba"
  }'
40) Pasos siguientes: Evitar que no admins puedan eliminar eventos, formateo, arreglar botones, testing de edicion
41) Cambios en tabla categorias para definir prioridad por categoria y cantidad de días con la que se deberá cargar un evento referenciado.
ALTER TABLE categorias 
ADD COLUMN prioridad ENUM('alta', 'media', 'baja') DEFAULT 'media',
ADD COLUMN dias_antelacion INT DEFAULT 15;
Actualizar categoriasController.js
Actualizar EventoForm.jsx
Actualizar GestionCategorias.jsx
-
-
-
-
-
-
Pasos Deploy: 
a) Copiar estructura de base de datos e insertarlo en el VPS de manera que sea.
b) Clonar repositorio
c) Crear conf de virtual host con apache2: sudo nano /etc/apache2/sites-available/sre.conf
d) Controlar apache2:
-Activar sitio: sudo a2ensite sre.conf
-Reiniciar apache: sudo systemctl restart apache2
-Verificar actividad de sitios: sudo apache2ctl -S
e) Instalar dependencias frontend y backend con npm install en cada directorio correspondiente.
f) Crear archivos .env 
g) Prueba backend con codigo hardcodeado:
_
node -e "
const db = require('./config/database.js');
db.execute('SELECT 1 + 1 AS result')
  .then(([rows]) => { console.log('Conexión BD exitosa:', rows); process.exit(0); })
  .catch(err => { console.error('Error BD:', err); process.exit(1); })
"
h) Crear servicio de ejecución de backend de la manera que sea, en este caso screen para probar
i) Prueba de url configurada en Apache con /api/health
j) Prueba de url con curl -I "url"
k) Creación de directorio para build: sudo mkdir -p /var/www/html/sre
l) Copiar build a la url del sitio: sudo cp -r build/* /var/www/html/sre/
m) Ajustar permisos de apache:
sudo chown -R www-data:www-data /var/www/html/sre
sudo chmod -R 755 /var/www/html/sre
sudo systemctl reload apache2

